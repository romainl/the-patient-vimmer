= Your screen
:stylesdir: css
:stylesheet: style2.css
:imagesdir: images
:scriptsdir: javascript
:linkcss:

Vim's screen may have a number of secondary UI elements such as a "`tabline`" or line numbers but it **always** contains _at least_ the following elements:

* a tab page, always containing at least...
* a window, always displaying...
* a buffer.

    (more intro to be written)

== Buffers

Like Word or Photoshop, Vim lets us create, delete and -- of course -- edit "`documents`", whether they are associated to an actual file or not. Those documents are called "`buffers`".

A buffer is the internal representation of the content of a file. Because you work on a representation of that file, your changes will not be written to disk unless you instruct Vim to do so with `:write` or `:update`.

As Vim's core file proxies, buffers are (or should be) at the core of your workflow and you owe it to yourself to know how to work with them to achieve reasonable efficiency.

=== Working with buffers

Every buffer created in Vim via `:edit`, `:find`, `:args`, any of their relatives or simply `$ vim filename` is added to the _buffer list_ where it is assigned a number that will never change until it is explicitly wiped out from the list. Beside that number, a buffer associated with a file will be named after that file, giving us a second way to address that buffer.

A typical Vim session could be short and only consist of editing a single file -- and thus a single buffer -- or it could go for weeks and consist of dozens and dozens of buffers. Keeping track of so many buffers would be daunting if Vim didn't give us not one, not two, but _three_ commands for listing buffers:

    :buffers
    :files
    :ls

All those commands do the same thing so we will simply use the shortest: `:ls`. Here is what its output looks like:

      1  h   "foo.txt"                      line 1
      2 #h   "bar.txt"                      line 1
      3 %a   "baz.txt"                      line 1
    Press ENTER or type command to continue

* The first column shows the buffer number.

* The second column gives us information on the state of the buffer, `h` means "`hidden`", `a` means "`active`", `%` marks the current buffer and `#` marks the "`alternate file`", which I usually think of as "`previous buffer`".

* The third column tells us the buffer name.

* And the last column shows the current position of the cursor.

No cursor, no active line, no selectionâ€¦ obviously, this list is not nicely interactive so what good is it? Well, the last line gives us a couple of hints: pressing `ENTER` unsurprisingly makes the list go away but we can also press `:` to enter command-line mode and use an Ex command to do something with the info we get from the list.

Buffers come with _a lot_ of navigation and management commands, let's see a few things we can do with the list above:

    :b1      " jump to buffer number 1
    :b#      " jump back to the previous buffer
    :bd 2    " delete buffer number 2

Unlike some other more "`modern`" editors, Vim doesn't have a built-in way of displaying a permanent list of loaded buffers. This may feel like a limitation if you are used to that feature but think about it for a moment... do you _really_ need that list when you are not trying to jump to another buffer?

Of course, it is not necessary to do `:ls` before doing `:b24` but who wants to keep a list of buffers updated in his head? Well... I certainly don't.

One way to avoid thinking too much about your buffers is to mash `:bn[ext]` and `:bp[revious]` until you get where you want. Your destination might be sixteen buffers away, though, so cycling is not a silver bullet.

But that boring `:ls`, then `<CR>`, then `:b`, then `24`, then `<CR>`, routine looks like a good candidate for a custom mapping:

    nnoremap <leader>b :ls<CR>:b

Here is how it looks:

    (gifcast)

== Windows

Vim gives us the ability to split our workspace in multiple windows -- often called "`splits`" -- to display different buffers or parts of a buffer. The exact mechanism is quite simple: the current window is split in two equal parts along the desired axis, _vertical_ or _horizontal_, and the cursor is placed in the new window.

The purpose of a window is to provide a view into a buffer. It can be created, moved around and closed but it is important to remember that windows and buffers are **totally** separated.

By default, the splitting is done to the left, which can be very intuitive.

=== Working with windows

== Tab pages

Tab pages -- too often referred to as "`tabs`" -- have been a neverending source of confusion since their appearance in Vim 7.x. Despite their name and how the <<_the_tabline,"`tabline`">> is implemented, Vim's _tab pages_ are not like other editor's _tabs_.

In other editors, "`tabs`" serve as proxies for documents. This means that the editor's "`tabline`" -- a list of tabs -- is effectively a list of documents and the user can use it to navigate from one tab to another and thus from one document to another. A "`tab`" _is_ for all intents and purposes a _document_ and there is no need to separate the tab _widget_ from the document it is associated to.

Switching to a "`tab`" is exactly like switching to a document.

In Vim, "`tab pages`" are _workspaces_, associated with "`tab`" widgets, themselves listed in a "`tabline`". The "`tab`" and "`tabline`" widgets work just like their counterparts in other editors but the _huge_ difference lies in the _workspace_ bit.

A workspace is a place where you arrange one or more windows displaying one or more buffers. But we have seen earlier that buffers are _global_ so, while it is entirely possible to have a single buffer displayed in a single window in a single tab page, it is impossible to have a one-to-one relationship between that buffer and that tab page without devising our own buffer/window/tab management paradigm.

Because "`tab`" widgets are not associated with specific buffers/files we simply can't use them as document proxies.

As collections of windows, tab pages offer a pretty good way to manage workspaces. They are ideal for scenarios where we need to have multiple pairs of files displayed side-by-side, or where we suddenly need to open a file from outside the current project...

Just like windows, the place of tab pages in our workflow depends largely on our needs. Using tab pages as file proxies is wrong, but refusing to use them altogether in the name of some imaginary purity is just as wrong. If not _more_.

So... how do we use them?

=== Working with tab pages

Creating a tab page is easy:

    :tabnew          " creates a new tab page containing one window
                     " displaying a new, unnamed, empty buffer.
    :tabedit file    " creates a new tab page containing one window
                     " displaying a buffer associated with 'file'.
    :tabfind file    " works similarly as the previous one but uses
                     " ':find' instead of ':edit'.

The commands above can't be easily shortened so one could very well create custom mappings along the same line as the ones we created earlier:

    nnoremap <leader>tn :tabnew<CR>
    nnoremap <leader>te :tabedit **/*
    nnoremap <leader>tf :tabfind *

Closing a tab page is just as easy:

    :tabclose      " closes the current tab page,
    :tabclose 3    " closes tab page number 3,
    :tabonly       " closes all tab pages except the current one.

Note that closing a tab page also closes its windows but _it doesn't delete the buffers currently displayed in those windows._

Switching to another tab page is also well covered and pretty intuitive:

    :tabfirst
    :tabnext
    :tabprevious
    :tablast

In normal mode, `gt` is the equivalent of `:tabnext` and `gT` is the equivalent of `:tabprevious`.

Here are a few example usages:

    (pic)

    (pic)

    (pic)

    (gifcast)

Like with buffers and windows, it is also possible to execute a command in each tab page: `:tabdo command`.

== Special Windows

Beyond the "`normal`" windows described above, Vim uses a number of very useful specialized windows.

=== The quickfix window

The quickfix is a handy list that we can populate and navigate at will. It actually is a bit more complicated but the quickfix list can be thought of as a list containing a number of entries made of:

* a filename,
* a line number,
* an optional column number,
* some text associated with the current item.

That list is global. This means that you can't have more than one active list at a time. One could recall previous lists with `:colder`, though, but I honestly never had to... so YMMV.

Vim comes with a lot of commands that populate the quickfix list, like `:grep` or `:vimgrep`, used for searching text in your project, and `:make`, used to build your program or pass them through a syntax checker. Once the quickfix is populated with valid entries, one can use a number of relatively intuitively named commands to navigate the list:

    :cfirst
    :clast
    :cnext
    :cprevious

or use `:copen` to open the interactive "`quickfix window`", or -- even better -- `:cwindow`:

    (gifcast)

See? The quickfix window is super-useful and super-easy to use.

The quickfix list has a close cousin called "`location list`" that pretty much works the same way except for these two differences:

* unlike the quickfix list, the location list is local to a window so you can have as many as you have windows,
* the commands start with an `l` instead of a `c`, `:lfirst`, `:lwindow`, etc.

Using the location list can be useful if you are heavily into windows and tab pages but the quickfix list is probably a simpler choice otherwise.

Now, repeating the `:w` & `:mak` & `:cw` dance over and over doesn't sound fun. Does it? Well, those commands can be chained with a `|`:

    :w|mak|cw

and recalled with `<Up>` so that's not such a big deal but there is still room for improvement, here:

* we have too many `<Enter>` to press,
* some kind of automation would be better.

Let's address the first issue by telling Vim to shut up with the `:silent` command:

    :w|silent mak|cw

A simple mapping would be a perfect alternative to all that typing. Let's try with `<F5>`, a shortcut often used in IDEs to compile the project, both in insert mode and normal mode:

    inoremap <F5> <Esc>:write|silent make|cwindow<CR>
    nnoremap <F5> :write|silent make|cwindow<CR>

Hmm... It looks like Vim doesn't like bars in mappings. That's understandable, actually: bars are used to separate commands but `inoremap <F5> <Esc>:write|silent make|cwindow<CR>` is _one_ command and the parts between bars don't really make sense on their own. So what can we do? Escape those bars?

Well yes:

    inoremap <F5> <Esc>:write\|silent make\|cwindow<CR>
    nnoremap <F5> :write\|silent make\|cwindow<CR>

or we can use `<Bar>`:

    inoremap <F5> <Esc>:write<Bar>silent make<Bar>cwindow<CR>
    nnoremap <F5> :write<Bar>silent make<Bar>cwindow<CR>

Let's see how it looks:

    (gifcast)

==== Reference

    :help quickfix
    :help :silent
    :help map_bar

=== The preview window

The preview window is a small window used to preview something, usually the signature of a function while we are working on its usage. It is a lot like a normal window except for these differences:

* opening the preview window doesn't steal the focus from the current window,
* there is only one preview window per tab page,
* it can be closed even if it is not focused.

This window can be opened with a bunch of commands, among which these ones:

    :ptag foo       " open tag 'foo' in a preview window
    <C-w>}          " open tag under the cursor in a preview window
    :psearch bar    " use include search to find 'bar' and open it in a preview window

And closed with: `:pclose` or `<C-w>z`.

Here is the preview window in action:

    (gifcast)

==== Reference

    :help preview-window

=== The Command-line window

The command-line is a handy way to input commands but it is not that good when it comes to editing the current command or recalling an old one and changing its parameters. This is not a design flaw or an implementation issue, though: only sane separation of concerns that should appeal to anyone used to the concept of *modal editing*.

You use insert mode to insert text and normal mode to edit text.

You use command-line mode to issue commands and the command-line window to edit the current command and command history.

Simple.

Opening the command-line window from the current command-line mode is done with `<C-f>`. This will open the relevant command history in the command-line window, with the current command ready for you to edit on the last line.

From normal mode, you can use `q:` to open the command-line history or `q/`/`q?` to open the search history, with the cursor in an empty line. Press `<CR>` in normal mode to run the current command or `:q` to quit that window.

Here is the command-line window in action:

    (gifcast)

Some hardcore Ex commands users like to use the command-line window instead of the usual command-line. This can be done by overriding `:` in normal mode:

    nnoremap : q:i

I don't recommend doing that, actually, but I think it is an interesting example of customization.

==== Reference

    :h cmdline-window

== Various UI elements

In addition to windows, we have many UI elements at our disposal for displaying information and/or interacting with one feature or another.

=== The tabline

   (picture)

The tabline is a list of "tabs" working as proxies for tab pages. Each tab shows some information on its associated tab page:

* the name of the buffer currently displayed in the currently focused window,
* the number of windows contained in the tab page when there is more than one,
* a `+` if one of the buffers displayed in one of the windows is "dirty".

If you have enabled mouse support in your `vimrc` and your terminal emulator supports that feature, you can use your mouse to switch to a tab page, reorder the tabs or close the current tab page by clicking on the `X` at the end of the tabline.

When to show a tabline can be defined with the `showtabline` option and what information to display depends on the `tabline` option.

While Vim's _tab pages_ are definitely not equivalent to other editor's _tabs_, Vim's _tabline_ looks and works a lot like its counterparts and suffers from the same usability issues.

The main issue is that tabs are used to display filenames and filenames take up a lot of horizontal space. A horizontal space that is physically limited and thus incapable of displaying more than a few tabs. Many solutions exist to remedy that problem: wrapping the tabline to form a second one, adding scrolling widgets at both ends of the tabline, grouping tabs, truncating filenames... The harsh reality is that none of those "solutions" is free of annoying side effects which, ultimately, can turn an otherwise good idea into an unusable gizmo.

The tabline and tab pages still have their use, mind you, but it is important to not think about them as you would in other editors.

==== Reference

    :help 'showtabline'
    :help 'tabline'
    :help setting-tabline

=== The statusline

    (picture)

The statusline is that "bar", at the bottom of windows, used to show information on the window itself or the buffer currently displayed in that window. It can also be used to resize windows if mouse support is enabled.

By default, the statusline is shown only when there is more than one window but this can be changed with the `laststatus` option:

    set laststatus=2

The default content of the statusline -- the filename and a status indicator -- is not exactly thrilling but it's possible to beef it up by enabling the `ruler` option that shows the line and colum of the cursor and tells how much of the buffer is currently visible.

It is very common, though, to customize it a bit further by playing with the `statusline` option that gives more control over the statusline's content and appearance.

This is how I define the statusline shown in the picture above, the explanation for each item can be found in `:help 'statusline'`:

    set statusline=%<\ %f\ %m%r%y%w%=\ L:\ \%l\/\%L\ C:\ \%c\

It is also possible to define colors for specific parts or use functions to display dynamic information not provided by Vim but I recommend measure, here: the statusline is an information device, not a decorative widget.

==== Reference

    :help 'laststatus'
    :help 'ruler'
    :help 'statusline'

=== Line numbers

Line numbers are a fairly straightforward feature that doesn't deserve much explanation. One enables it with `:set number`, disables it with `:set nonumber` and decides how much room they take with `:set numberwidth=6`.

In most editors or IDEs, line numbers are only used directly by users in two ways: to communicate with other people who work on the same code and to jump to a specific line.

In addition, Vim allows us to use line numbers to define the range and/or the address for many Ex commands:

    33G          " go to line 33
    V13G         " linewise visual selection from here to line 13
    :2t24        " copy line 2 after line 24
    :m12         " move current line after line 12
    :8,17d       " delete lines 8 to 17
    :46put=@f    " put content of register f after line 46

But we are not limited to absolute line numbers: we can use relative line numbers to see how far a line is from the current line.

    (screenshot)

Relative numbers can be enabled with `set relativenumber` and used in the same way as absolute line numbers:

    6j           " go down 6 lines
    V5k          " linewise visual selection from here to 5 lines above
    :-2,+6m45    " move lines from 2 lines above to 6 lines below after line 45

==== Reference

    :help 'number'
    :help 'numberwidth'
    :help 'relativenumber'

=== The fold column

    (picture)

The `"fold column"` is disabled by default but can be enabled by setting the `foldcolumn` option to a number between 1 and 12. It is used to show information about the folds in your buffer and let you open and close them with the mouse if mouse support is enabled.

Open folds are marked with a clickable `-`, lines belonging to a fold are marked with a `|` and closed folds are marked with a clickable `+`.

==== Reference

    :h fold-foldcolumn
    :h 'foldcolumn'

=== The sign column

    (picture)

The "sign column" can't be shown or hidden easily: Vim shows it when you have one or more signs in your buffer and removes it when there's no sign anymore.

The color and content of individual signs is usually defined by plugin authors whereas the background of the column is the responsibility of your colorscheme.

==== Reference

    :help signs

=== The completion menu

    (picture)

The completion menu comes up when you press one of the many key-combinations affected to insert mode completion and there is at least one or more possible completions. In pure "modal" fashion, once the menu is displayed, some keys acquire a new meaning to allow cursor movement and selection but the general pattern stays consistent with the general Vim UI and works more or less how we expect.

problems and solutions (to be written)

==== Reference

    :help ins-completion-menu

=== The command-line

    (picture)

The command-line is Vim's main interface. Like the prompt of your computer's shell, it is used to send commands to Vim and for feedback if necessary.

==== Reference

== Conclusion

(to be written)

++++
<div id="front">
    <a href="#" id="open-close">...</a>
    <ul>
        <li>
            <a href="0.html">0&nbsp;&nbsp;&nbsp;An introduction</a>
        </li>
        <li>
            <a href="1.html">1&nbsp;&nbsp;&nbsp;Lord of the files</a>
        </li>
        <li class="current">
            <a href="2.html">2&nbsp;&nbsp;&nbsp;Your workspace</a>
        </li>
        <li>
            <a href="3.html">3&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="4.html">4&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="5.html">5&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="6.html">6&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="7.html">7&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
        <li>
            <a href="8.html">8&nbsp;&nbsp;&nbsp;Title pending</a>
        </li>
    </ul>
</div>
<h6>The Patient Vimmer</h6>
<div id="bottom">
    <p>Written by <a href="https://github.com/romainl">Romain Lafourcade</a>, with help from <a href="https://github.com/dahu/">Barry Arthur</a> and the #vim community.</p>
<p>Copyleft 2015</p>
</div>
<script src="javascript/behavior.js"></script>
++++
